<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Kind (bitwuzla-cxx.Bitwuzla_cxx.S.Kind)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../../index.html">Index</a> &#x00BB; <a href="../../../index.html">bitwuzla-cxx</a> &#x00BB; <a href="../../index.html">Bitwuzla_cxx</a> &#x00BB; <a href="../index.html">S</a> &#x00BB; Kind</nav><header class="odoc-preamble"><h1>Module <code><span>S.Kind</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = </span></code><ol><li id="type-t.Constant" class="def variant constructor anchored"><a href="#type-t.Constant" class="anchor"></a><code><span>| </span><span><span class="constructor">Constant</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>First order constant.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Const_array" class="def variant constructor anchored"><a href="#type-t.Const_array" class="anchor"></a><code><span>| </span><span><span class="constructor">Const_array</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Constant array.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Value" class="def variant constructor anchored"><a href="#type-t.Value" class="anchor"></a><code><span>| </span><span><span class="constructor">Value</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Value.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Variable" class="def variant constructor anchored"><a href="#type-t.Variable" class="anchor"></a><code><span>| </span><span><span class="constructor">Variable</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bound variable.</p><span class="comment-delim">*)</span></div></li><li id="type-t.And" class="def variant constructor anchored"><a href="#type-t.And" class="anchor"></a><code><span>| </span><span><span class="constructor">And</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Boolean and.</p><p>SMT-LIB: <code>and</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Distinct" class="def variant constructor anchored"><a href="#type-t.Distinct" class="anchor"></a><code><span>| </span><span><span class="constructor">Distinct</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Disequality.</p><p>SMT-LIB: <code>distinct</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Equal" class="def variant constructor anchored"><a href="#type-t.Equal" class="anchor"></a><code><span>| </span><span><span class="constructor">Equal</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Equality.</p><p>SMT-LIB: <code>=</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Iff" class="def variant constructor anchored"><a href="#type-t.Iff" class="anchor"></a><code><span>| </span><span><span class="constructor">Iff</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Boolean if and only if.</p><p>SMT-LIB: <code>=</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Implies" class="def variant constructor anchored"><a href="#type-t.Implies" class="anchor"></a><code><span>| </span><span><span class="constructor">Implies</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Boolean implies.</p><p>SMT-LIB: <code>=&gt;</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Not" class="def variant constructor anchored"><a href="#type-t.Not" class="anchor"></a><code><span>| </span><span><span class="constructor">Not</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Boolean not.</p><p>SMT-LIB: <code>not</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Or" class="def variant constructor anchored"><a href="#type-t.Or" class="anchor"></a><code><span>| </span><span><span class="constructor">Or</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Boolean or.</p><p>SMT-LIB: <code>or</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Xor" class="def variant constructor anchored"><a href="#type-t.Xor" class="anchor"></a><code><span>| </span><span><span class="constructor">Xor</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Boolean xor.</p><p>SMT-LIB: <code>xor</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Ite" class="def variant constructor anchored"><a href="#type-t.Ite" class="anchor"></a><code><span>| </span><span><span class="constructor">Ite</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>If-then-else.</p><p>SMT-LIB: <code>ite</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Exists" class="def variant constructor anchored"><a href="#type-t.Exists" class="anchor"></a><code><span>| </span><span><span class="constructor">Exists</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Existential quantification.</p><p>SMT-LIB: <code>exists</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Forall" class="def variant constructor anchored"><a href="#type-t.Forall" class="anchor"></a><code><span>| </span><span><span class="constructor">Forall</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Universal quantification.</p><p>SMT-LIB: <code>forall</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Apply" class="def variant constructor anchored"><a href="#type-t.Apply" class="anchor"></a><code><span>| </span><span><span class="constructor">Apply</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Function application.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Lambda" class="def variant constructor anchored"><a href="#type-t.Lambda" class="anchor"></a><code><span>| </span><span><span class="constructor">Lambda</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Lambda.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Select" class="def variant constructor anchored"><a href="#type-t.Select" class="anchor"></a><code><span>| </span><span><span class="constructor">Select</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Array select.</p><p>SMT-LIB: <code>select</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Store" class="def variant constructor anchored"><a href="#type-t.Store" class="anchor"></a><code><span>| </span><span><span class="constructor">Store</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Array store.</p><p>SMT-LIB: <code>store</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_add" class="def variant constructor anchored"><a href="#type-t.Bv_add" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_add</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector addition.</p><p>SMT-LIB: <code>bvadd</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_and" class="def variant constructor anchored"><a href="#type-t.Bv_and" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_and</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector and.</p><p>SMT-LIB: <code>bvand</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_ashr" class="def variant constructor anchored"><a href="#type-t.Bv_ashr" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_ashr</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector arithmetic right shift.</p><p>SMT-LIB: <code>bvashr</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_comp" class="def variant constructor anchored"><a href="#type-t.Bv_comp" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_comp</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector comparison.</p><p>SMT-LIB: <code>bvcomp</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_concat" class="def variant constructor anchored"><a href="#type-t.Bv_concat" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_concat</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector concat.</p><p>SMT-LIB: <code>concat</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_dec" class="def variant constructor anchored"><a href="#type-t.Bv_dec" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_dec</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector decrement.</p><p>Decrement by one.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_inc" class="def variant constructor anchored"><a href="#type-t.Bv_inc" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_inc</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector increment.</p><p>Increment by one.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_mul" class="def variant constructor anchored"><a href="#type-t.Bv_mul" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_mul</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector multiplication.</p><p>SMT-LIB: <code>bvmul</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_nand" class="def variant constructor anchored"><a href="#type-t.Bv_nand" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_nand</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector nand.</p><p>SMT-LIB: <code>bvnand</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_neg" class="def variant constructor anchored"><a href="#type-t.Bv_neg" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_neg</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector negation (two's complement).</p><p>SMT-LIB: <code>bvneg</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_nego" class="def variant constructor anchored"><a href="#type-t.Bv_nego" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_nego</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector negation overflow test.</p><p>Predicate indicating if bit-vector negation produces an overflow.</p><p>SMT-LIB: <code>bvnego</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_nor" class="def variant constructor anchored"><a href="#type-t.Bv_nor" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_nor</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector nor.</p><p>SMT-LIB: <code>bvnor</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_not" class="def variant constructor anchored"><a href="#type-t.Bv_not" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_not</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector not (one's complement).</p><p>SMT-LIB: <code>bvnot</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_or" class="def variant constructor anchored"><a href="#type-t.Bv_or" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_or</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector or.</p><p>SMT-LIB: <code>bvor</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_redand" class="def variant constructor anchored"><a href="#type-t.Bv_redand" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_redand</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector and reduction.</p><p>Bit-wise <b>and</b> reduction, all bits are <b>and</b>'ed together into a single bit. This corresponds to bit-wise <b>and</b> reduction as known from Verilog.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_redor" class="def variant constructor anchored"><a href="#type-t.Bv_redor" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_redor</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector reduce or.</p><p>Bit-wise <b>or</b> reduction, all bits are <b>or</b>'ed together into a single bit. This corresponds to bit-wise <b>or</b> reduction as known from Verilog.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_redxor" class="def variant constructor anchored"><a href="#type-t.Bv_redxor" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_redxor</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector reduce xor.</p><p>Bit-wise <b>xor</b> reduction, all bits are <b>xor</b>'ed together into a single bit. This corresponds to bit-wise <b>xor</b> reduction as known from Verilog.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_rol" class="def variant constructor anchored"><a href="#type-t.Bv_rol" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_rol</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector rotate left (not indexed).</p><p>This is a non-indexed variant of SMT-LIB <code>rotate_left</code>.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_ror" class="def variant constructor anchored"><a href="#type-t.Bv_ror" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_ror</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector rotate right.</p><p>This is a non-indexed variant of SMT-LIB <code>rotate_right</code>.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_saddo" class="def variant constructor anchored"><a href="#type-t.Bv_saddo" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_saddo</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector signed addition overflow test.</p><p>Single bit to indicate if signed addition produces an overflow.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_sdivo" class="def variant constructor anchored"><a href="#type-t.Bv_sdivo" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_sdivo</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector signed division overflow test.</p><p>Single bit to indicate if signed division produces an overflow.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_sdiv" class="def variant constructor anchored"><a href="#type-t.Bv_sdiv" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_sdiv</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector signed division.</p><p>SMT-LIB: <code>bvsdiv</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_sge" class="def variant constructor anchored"><a href="#type-t.Bv_sge" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_sge</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector signed greater than or equal.</p><p>SMT-LIB: <code>bvsge</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_sgt" class="def variant constructor anchored"><a href="#type-t.Bv_sgt" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_sgt</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector signed greater than.</p><p>SMT-LIB: <code>bvsgt</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_shl" class="def variant constructor anchored"><a href="#type-t.Bv_shl" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_shl</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector logical left shift.</p><p>SMT-LIB: <code>bvshl</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_shr" class="def variant constructor anchored"><a href="#type-t.Bv_shr" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_shr</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector logical right shift.</p><p>SMT-LIB: <code>bvshr</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_sle" class="def variant constructor anchored"><a href="#type-t.Bv_sle" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_sle</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector signed less than or equal.</p><p>SMT-LIB: <code>bvsle</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_slt" class="def variant constructor anchored"><a href="#type-t.Bv_slt" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_slt</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector signed less than.</p><p>SMT-LIB: <code>bvslt</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_smod" class="def variant constructor anchored"><a href="#type-t.Bv_smod" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_smod</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector signed modulo.</p><p>SMT-LIB: <code>bvsmod</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_smulo" class="def variant constructor anchored"><a href="#type-t.Bv_smulo" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_smulo</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector signed multiplication overflow test.</p><p>SMT-LIB: <code>bvsmod</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_srem" class="def variant constructor anchored"><a href="#type-t.Bv_srem" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_srem</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector signed remainder.</p><p>SMT-LIB: <code>bvsrem</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_ssubo" class="def variant constructor anchored"><a href="#type-t.Bv_ssubo" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_ssubo</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector signed subtraction overflow test.</p><p>Single bit to indicate if signed subtraction produces an overflow.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_sub" class="def variant constructor anchored"><a href="#type-t.Bv_sub" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_sub</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector subtraction.</p><p>SMT-LIB: <code>bvsub</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_uaddo" class="def variant constructor anchored"><a href="#type-t.Bv_uaddo" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_uaddo</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector unsigned addition overflow test.</p><p>Single bit to indicate if unsigned addition produces an overflow.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_udiv" class="def variant constructor anchored"><a href="#type-t.Bv_udiv" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_udiv</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector unsigned division.</p><p>SMT-LIB: <code>bvudiv</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_uge" class="def variant constructor anchored"><a href="#type-t.Bv_uge" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_uge</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector unsigned greater than or equal.</p><p>SMT-LIB: <code>bvuge</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_ugt" class="def variant constructor anchored"><a href="#type-t.Bv_ugt" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_ugt</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector unsigned greater than.</p><p>SMT-LIB: <code>bvugt</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_ule" class="def variant constructor anchored"><a href="#type-t.Bv_ule" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_ule</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector unsigned less than or equal.</p><p>SMT-LIB: <code>bvule</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_ult" class="def variant constructor anchored"><a href="#type-t.Bv_ult" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_ult</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector unsigned less than.</p><p>SMT-LIB: <code>bvult</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_umulo" class="def variant constructor anchored"><a href="#type-t.Bv_umulo" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_umulo</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector unsigned multiplication overflow test.</p><p>Single bit to indicate if unsigned multiplication produces an overflow.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_urem" class="def variant constructor anchored"><a href="#type-t.Bv_urem" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_urem</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector unsigned remainder.</p><p>SMT-LIB: <code>bvurem</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_usubo" class="def variant constructor anchored"><a href="#type-t.Bv_usubo" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_usubo</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector unsigned subtraction overflow test.</p><p>Single bit to indicate if unsigned subtraction produces an overflow.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_xnor" class="def variant constructor anchored"><a href="#type-t.Bv_xnor" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_xnor</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector xnor.</p><p>SMT-LIB: <code>bvxnor</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_xor" class="def variant constructor anchored"><a href="#type-t.Bv_xor" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_xor</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector xor.</p><p>SMT-LIB: <code>bvxor</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_extract" class="def variant constructor anchored"><a href="#type-t.Bv_extract" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_extract</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector extract.</p><p>SMT-LIB: <code>extract</code> (indexed)</p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_repeat" class="def variant constructor anchored"><a href="#type-t.Bv_repeat" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_repeat</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector repeat.</p><p>SMT-LIB: <code>repeat</code> (indexed)</p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_roli" class="def variant constructor anchored"><a href="#type-t.Bv_roli" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_roli</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector rotate left by integer.</p><p>SMT-LIB: <code>rotate_left</code> (indexed)</p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_rori" class="def variant constructor anchored"><a href="#type-t.Bv_rori" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_rori</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector rotate right by integer.</p><p>SMT-LIB: <code>rotate_right</code> (indexed)</p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_sign_extend" class="def variant constructor anchored"><a href="#type-t.Bv_sign_extend" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_sign_extend</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector sign extend.</p><p>SMT-LIB: <code>sign_extend</code> (indexed)</p><span class="comment-delim">*)</span></div></li><li id="type-t.Bv_zero_extend" class="def variant constructor anchored"><a href="#type-t.Bv_zero_extend" class="anchor"></a><code><span>| </span><span><span class="constructor">Bv_zero_extend</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bit-vector zero extend.</p><p>SMT-LIB: <code>zero_extend</code> (indexed)</p><span class="comment-delim">*)</span></div></li><li id="type-t.Fp_abs" class="def variant constructor anchored"><a href="#type-t.Fp_abs" class="anchor"></a><code><span>| </span><span><span class="constructor">Fp_abs</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Floating-point absolute value.</p><p>SMT-LIB: <code>fp.abs</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Fp_add" class="def variant constructor anchored"><a href="#type-t.Fp_add" class="anchor"></a><code><span>| </span><span><span class="constructor">Fp_add</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Floating-point addition.</p><p>SMT-LIB: <code>fp.add</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Fp_div" class="def variant constructor anchored"><a href="#type-t.Fp_div" class="anchor"></a><code><span>| </span><span><span class="constructor">Fp_div</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Floating-point division.</p><p>SMT-LIB: <code>fp.div</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Fp_equal" class="def variant constructor anchored"><a href="#type-t.Fp_equal" class="anchor"></a><code><span>| </span><span><span class="constructor">Fp_equal</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Floating-point equality.</p><p>SMT-LIB: <code>fp.eq</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Fp_fma" class="def variant constructor anchored"><a href="#type-t.Fp_fma" class="anchor"></a><code><span>| </span><span><span class="constructor">Fp_fma</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Floating-point fused multiplcation and addition.</p><p>SMT-LIB: <code>fp.fma</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Fp_fp" class="def variant constructor anchored"><a href="#type-t.Fp_fp" class="anchor"></a><code><span>| </span><span><span class="constructor">Fp_fp</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Floating-point IEEE 754 value.</p><p>SMT-LIB: <code>fp</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Fp_geq" class="def variant constructor anchored"><a href="#type-t.Fp_geq" class="anchor"></a><code><span>| </span><span><span class="constructor">Fp_geq</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Floating-point greater than or equal.</p><p>SMT-LIB: <code>fp.geq</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Fp_gt" class="def variant constructor anchored"><a href="#type-t.Fp_gt" class="anchor"></a><code><span>| </span><span><span class="constructor">Fp_gt</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Floating-point greater than.</p><p>SMT-LIB: <code>fp.gt</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Fp_is_inf" class="def variant constructor anchored"><a href="#type-t.Fp_is_inf" class="anchor"></a><code><span>| </span><span><span class="constructor">Fp_is_inf</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Floating-point is infinity tester.</p><p>SMT-LIB: <code>fp.isInfinite</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Fp_is_nan" class="def variant constructor anchored"><a href="#type-t.Fp_is_nan" class="anchor"></a><code><span>| </span><span><span class="constructor">Fp_is_nan</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Floating-point is Nan tester.</p><p>SMT-LIB: <code>fp.isNaN</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Fp_is_neg" class="def variant constructor anchored"><a href="#type-t.Fp_is_neg" class="anchor"></a><code><span>| </span><span><span class="constructor">Fp_is_neg</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Floating-point is negative tester.</p><p>SMT-LIB: <code>fp.isNegative</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Fp_is_normal" class="def variant constructor anchored"><a href="#type-t.Fp_is_normal" class="anchor"></a><code><span>| </span><span><span class="constructor">Fp_is_normal</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Floating-point is normal tester.</p><p>SMT-LIB: <code>fp.isNormal</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Fp_is_pos" class="def variant constructor anchored"><a href="#type-t.Fp_is_pos" class="anchor"></a><code><span>| </span><span><span class="constructor">Fp_is_pos</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Floating-point is positive tester.</p><p>SMT-LIB: <code>fp.isPositive</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Fp_is_subnormal" class="def variant constructor anchored"><a href="#type-t.Fp_is_subnormal" class="anchor"></a><code><span>| </span><span><span class="constructor">Fp_is_subnormal</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Floating-point is subnormal tester.</p><p>SMT-LIB: <code>fp.isSubnormal</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Fp_is_zero" class="def variant constructor anchored"><a href="#type-t.Fp_is_zero" class="anchor"></a><code><span>| </span><span><span class="constructor">Fp_is_zero</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Floating-point is zero tester.</p><p>SMT-LIB: <code>fp.isZero</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Fp_leq" class="def variant constructor anchored"><a href="#type-t.Fp_leq" class="anchor"></a><code><span>| </span><span><span class="constructor">Fp_leq</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Floating-point less than or equal.</p><p>SMT-LIB: <code>fp.leq</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Fp_lt" class="def variant constructor anchored"><a href="#type-t.Fp_lt" class="anchor"></a><code><span>| </span><span><span class="constructor">Fp_lt</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Floating-point less than.</p><p>SMT-LIB: <code>fp.lt</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Fp_max" class="def variant constructor anchored"><a href="#type-t.Fp_max" class="anchor"></a><code><span>| </span><span><span class="constructor">Fp_max</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Floating-point max.</p><p>SMT-LIB: <code>fp.max</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Fp_min" class="def variant constructor anchored"><a href="#type-t.Fp_min" class="anchor"></a><code><span>| </span><span><span class="constructor">Fp_min</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Floating-point min.</p><p>SMT-LIB: <code>fp.min</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Fp_mul" class="def variant constructor anchored"><a href="#type-t.Fp_mul" class="anchor"></a><code><span>| </span><span><span class="constructor">Fp_mul</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Floating-point multiplcation.</p><p>SMT-LIB: <code>fp.mul</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Fp_neg" class="def variant constructor anchored"><a href="#type-t.Fp_neg" class="anchor"></a><code><span>| </span><span><span class="constructor">Fp_neg</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Floating-point negation.</p><p>SMT-LIB: <code>fp.neg</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Fp_rem" class="def variant constructor anchored"><a href="#type-t.Fp_rem" class="anchor"></a><code><span>| </span><span><span class="constructor">Fp_rem</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Floating-point remainder.</p><p>SMT-LIB: <code>fp.rem</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Fp_rti" class="def variant constructor anchored"><a href="#type-t.Fp_rti" class="anchor"></a><code><span>| </span><span><span class="constructor">Fp_rti</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Floating-point round to integral.</p><p>SMT-LIB: <code>fp.roundToIntegral</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Fp_sqrt" class="def variant constructor anchored"><a href="#type-t.Fp_sqrt" class="anchor"></a><code><span>| </span><span><span class="constructor">Fp_sqrt</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Floating-point round to square root.</p><p>SMT-LIB: <code>fp.sqrt</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Fp_sub" class="def variant constructor anchored"><a href="#type-t.Fp_sub" class="anchor"></a><code><span>| </span><span><span class="constructor">Fp_sub</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Floating-point round to subtraction.</p><p>SMT-LIB: <code>fp.sqrt</code></p><span class="comment-delim">*)</span></div></li><li id="type-t.Fp_to_fp_from_bv" class="def variant constructor anchored"><a href="#type-t.Fp_to_fp_from_bv" class="anchor"></a><code><span>| </span><span><span class="constructor">Fp_to_fp_from_bv</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Floating-point to_fp from IEEE 754 bit-vector.</p><p>SMT-LIB: <code>to_fp</code> (indexed)</p><span class="comment-delim">*)</span></div></li><li id="type-t.Fp_to_fp_from_fp" class="def variant constructor anchored"><a href="#type-t.Fp_to_fp_from_fp" class="anchor"></a><code><span>| </span><span><span class="constructor">Fp_to_fp_from_fp</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Floating-point to_fp from floating-point.</p><p>SMT-LIB: <code>to_fp</code> (indexed)</p><span class="comment-delim">*)</span></div></li><li id="type-t.Fp_to_fp_from_sbv" class="def variant constructor anchored"><a href="#type-t.Fp_to_fp_from_sbv" class="anchor"></a><code><span>| </span><span><span class="constructor">Fp_to_fp_from_sbv</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Floating-point to_fp from signed bit-vector value.</p><p>SMT-LIB: <code>to_fp</code> (indexed)</p><span class="comment-delim">*)</span></div></li><li id="type-t.Fp_to_fp_from_ubv" class="def variant constructor anchored"><a href="#type-t.Fp_to_fp_from_ubv" class="anchor"></a><code><span>| </span><span><span class="constructor">Fp_to_fp_from_ubv</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Floating-point to_fp from unsigned bit-vector value.</p><p>SMT-LIB: <code>to_fp_unsigned</code> (indexed)</p><span class="comment-delim">*)</span></div></li><li id="type-t.Fp_to_sbv" class="def variant constructor anchored"><a href="#type-t.Fp_to_sbv" class="anchor"></a><code><span>| </span><span><span class="constructor">Fp_to_sbv</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Floating-point to_sbv.</p><p>SMT-LIB: <code>fp.to_sbv</code> (indexed)</p><span class="comment-delim">*)</span></div></li><li id="type-t.Fp_to_ubv" class="def variant constructor anchored"><a href="#type-t.Fp_to_ubv" class="anchor"></a><code><span>| </span><span><span class="constructor">Fp_to_ubv</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Floating-point to_ubv.</p><p>SMT-LIB: <code>fp.to_ubv</code> (indexed)</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>The term kind.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span><span class="keyword">val</span> to_string : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>to_string t</code> get string representation of this kind.</p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>String representation of this kind.</p></li></ul></div></div></div></body></html>
